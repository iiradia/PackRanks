{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\n\n\nfunction getLowestCommonAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n  var depthA = 0;\n\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\n    depthA++;\n  }\n\n  var depthB = 0;\n\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\n    depthB++;\n  } // If A is deeper, crawl up.\n\n\n  while (depthA - depthB > 0) {\n    instA = instA._hostParent;\n    depthA--;\n  } // If B is deeper, crawl up.\n\n\n  while (depthB - depthA > 0) {\n    instB = instB._hostParent;\n    depthB--;\n  } // Walk in lockstep until we find a match.\n\n\n  var depth = depthA;\n\n  while (depth--) {\n    if (instA === instB) {\n      return instA;\n    }\n\n    instA = instA._hostParent;\n    instB = instB._hostParent;\n  }\n\n  return null;\n}\n/**\n * Return if A is an ancestor of B.\n */\n\n\nfunction isAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n\n  while (instB) {\n    if (instB === instA) {\n      return true;\n    }\n\n    instB = instB._hostParent;\n  }\n\n  return false;\n}\n/**\n * Return the parent instance of the passed-in instance.\n */\n\n\nfunction getParentInstance(inst) {\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\n  return inst._hostParent;\n}\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\n\n\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n\n  while (inst) {\n    path.push(inst);\n    inst = inst._hostParent;\n  }\n\n  var i;\n\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = from._hostParent;\n  }\n\n  var pathTo = [];\n\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = to._hostParent;\n  }\n\n  var i;\n\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n\n  for (i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n\nmodule.exports = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave\n};","map":{"version":3,"sources":["/Users/mathew/EasyA/reactjs/node_modules/react-simplert/node_modules/react-dom/lib/ReactDOMTreeTraversal.js"],"names":["_prodInvariant","require","invariant","getLowestCommonAncestor","instA","instB","process","env","NODE_ENV","depthA","tempA","_hostParent","depthB","tempB","depth","isAncestor","getParentInstance","inst","traverseTwoPhase","fn","arg","path","push","i","length","traverseEnterLeave","from","to","argFrom","argTo","common","pathFrom","pathTo","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant');\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;\n\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = tempA._hostParent) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = tempB._hostParent) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = instA._hostParent;\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = instB._hostParent;\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB) {\n      return instA;\n    }\n    instA = instA._hostParent;\n    instB = instB._hostParent;\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;\n\n  while (instB) {\n    if (instB === instA) {\n      return true;\n    }\n    instB = instB._hostParent;\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;\n\n  return inst._hostParent;\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = inst._hostParent;\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = from._hostParent;\n  }\n  var pathTo = [];\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = to._hostParent;\n  }\n  var i;\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (i = pathTo.length; i-- > 0;) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n\nmodule.exports = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave\n};"]},"metadata":{},"sourceType":"script"}