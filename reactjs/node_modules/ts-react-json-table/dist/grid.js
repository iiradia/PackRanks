"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var gridHeader_1 = require("./gridHeader");
var gridBody_1 = require("./gridBody");
var gridFooter_1 = require("./gridFooter");
var polyfills_1 = require("./polyfills");
polyfills_1.polyfills();
var JsonTable = /** @class */ (function (_super) {
    __extends(JsonTable, _super);
    function JsonTable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.defaultSettings = {
            header: true,
            noRowsMessage: 'No items',
            classPrefix: 'json',
        };
        _this.headerGrouping = false;
        return _this;
    }
    JsonTable.prototype.render = function () {
        this.createSettings();
        this.columns = this.createColumns();
        this.className = this.props.className || this.settings.classPrefix + "Table";
        var header = this.settings.header ? React.createElement(gridHeader_1.GridHeader, { theadClassName: this.props.theadClassName, key: 'jt-header', settings: this.settings, columns: this.columns, onClickHeader: this.props.onClickHeader, grouping: this.headerGrouping }) : null;
        var caption = this.props.caption ? React.createElement("caption", null, this.props.caption) : null;
        var table = React.createElement("div", null,
            React.createElement("div", { style: { position: "relative", overflow: "hidden" } },
                React.createElement("table", { className: this.className, key: 'jt-table' },
                    caption,
                    header,
                    React.createElement(gridBody_1.GridBody, { key: 'jt-body', settings: this.settings, columns: this.columns, rows: this.props.rows, onClickRow: this.props.onClickRow, onClickCell: this.props.onClickCell }),
                    React.createElement(gridFooter_1.GridFooter, { key: 'jt-footer' }))));
        return this.settings.freezeHeader ?
            React.createElement("div", { className: "scrollingtable" },
                React.createElement("div", null,
                    React.createElement("div", null, table))) : table;
    };
    JsonTable.prototype.createSettings = function () {
        if (this.props.settings) {
            this.settings = this.props.settings;
        }
        else {
            this.settings = this.defaultSettings;
        }
        if (this.settings.header == null)
            this.settings.header = true;
        if (this.settings.noRowsMessage == null)
            this.settings.noRowsMessage = this.defaultSettings.noRowsMessage;
        if (this.settings.classPrefix == null)
            this.settings.classPrefix = this.defaultSettings.classPrefix;
    };
    JsonTable.prototype.createColumns = function () {
        var _this = this;
        if (!this.props.rows || this.props.rows.length === 0) {
            return [];
        }
        var columns;
        if (!this.props.columns) {
            columns = Object.keys(this.props.rows[0]).map(function (key) {
                return {
                    key: key,
                    label: key,
                    cell: _this.settings.cellRenderer || key,
                };
            });
        }
        else {
            columns = this.props.columns.map(function (column) {
                if (typeof column == 'string') {
                    return {
                        key: column,
                        label: column,
                        cell: _this.settings.cellRenderer || column
                    };
                }
                if (typeof column == 'object') {
                    var key = column.key || column.label;
                    if (column.group)
                        _this.headerGrouping = true;
                    return {
                        key: key,
                        label: column.label || key,
                        cell: _this.settings.cellRenderer || column.cell || key,
                        objectDisplayStyle: column.objectDisplayStyle,
                        group: column.group
                    };
                }
            });
        }
        if (this.props.excludeColumns && this.props.excludeColumns.length !== 0) {
            var toDelete_1 = [];
            this.props.excludeColumns.forEach(function (key) {
                toDelete_1.push(columns.findIndex(function (column) { return column.key === key; }));
            });
            toDelete_1.forEach(function (index) {
                if (index !== -1)
                    columns.splice(index, 1);
            });
        }
        var copyObject = function (index, columnDefinition) {
            if (index !== -1) {
                Object.keys(columnDefinition).forEach(function (key) {
                    columns[index][key] = columnDefinition[key];
                });
                return true;
            }
            return false;
        };
        if (this.props.columnDefinitions && this.props.columnDefinitions.length > 0) {
            this.props.columnDefinitions.forEach(function (def) {
                var index = columns.findIndex(function (column) { return column.key === def.key; });
                if (!copyObject(index, def)) {
                    var dotIndex_1 = def.key.indexOf('.');
                    if (dotIndex_1 !== -1) {
                        index = columns.findIndex(function (column) { return column.key === def.key.substring(0, dotIndex_1); });
                        if (copyObject(index, def)) {
                            columns[index].cell = _this.settings.cellRenderer || def.cell || def.key;
                        }
                        else {
                            index = columns.findIndex(function (column) { return column.key.indexOf(def.key.substring(0, dotIndex_1 + 1)) !== -1; });
                            if (index !== -1) {
                                var newIndex = index + 1;
                                columns.splice(newIndex, 0, def);
                                copyObject(newIndex, def);
                                columns[newIndex].cell = _this.settings.cellRenderer || def.cell || def.key;
                            }
                        }
                    }
                }
                if (def.group)
                    _this.headerGrouping = true;
            });
        }
        if (this.headerGrouping) {
            var group_1;
            var colSpans_1 = new Map();
            var colSpan_1 = 1;
            columns.forEach(function (column) {
                if (column.group) {
                    if (column.group === group_1) {
                        colSpans_1.set(column.group, ++colSpan_1);
                    }
                    else {
                        group_1 = column.group;
                        column.groupIndex = 0;
                        colSpan_1 = 1;
                    }
                }
            });
            Array.from(colSpans_1.keys()).forEach(function (group) {
                var index = columns.findIndex(function (column) { return column.group === group && column.groupIndex === 0; });
                columns[index].colSpan = colSpans_1.get(group);
            });
        }
        return columns;
    };
    return JsonTable;
}(React.Component));
exports.JsonTable = JsonTable;
module.exports = JsonTable;
//# sourceMappingURL=grid.js.map