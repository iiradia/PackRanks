{"ast":null,"code":"/**\n * Expose `pathtoRegexp`.\n */\nmodule.exports = pathtoRegexp;\n/**\n * Match matching groups in a regular expression.\n */\n\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?')).replace(/\\/\\(/g, '/(?:').replace(/([\\/\\.])/g, '\\\\$1').replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n    slash = slash || '';\n    format = format || '';\n    capture = capture || '([^\\\\/' + format + ']+?)';\n    optional = optional || '';\n    keys.push({\n      name: key,\n      optional: !!optional,\n      offset: offset + extraOffset\n    });\n    var result = '' + (optional ? '' : slash) + '(?:' + format + (optional ? slash : '') + capture + (star ? '((?:[\\\\/' + format + '].+?)?)' : '') + ')' + optional;\n    extraOffset += result.length - match.length;\n    return result;\n  }).replace(/\\*/g, function (star, index) {\n    var len = keys.length;\n\n    while (len-- > keysOffset && keys[len].offset > index) {\n      keys[len].offset += 3; // Replacement length minus asterisk length.\n    }\n\n    return '(.*)';\n  }); // This is a workaround for handling unnamed matching groups.\n\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    } // It's possible to escape the bracket.\n\n\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++,\n        // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  } // If the path is non-ending, match until the end or a slash.\n\n\n  path += end ? '$' : path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)';\n  return new RegExp(path, flags);\n}\n\n;","map":{"version":3,"sources":["/home/iiradia/EasyA/reactjs/node_modules/path-to-regexp/index.js"],"names":["module","exports","pathtoRegexp","MATCHING_GROUP_REGEXP","path","keys","options","strict","end","flags","sensitive","extraOffset","keysOffset","length","i","name","m","RegExp","exec","source","push","optional","offset","index","Array","isArray","map","value","join","replace","match","slash","format","key","capture","star","result","len","escapeCount","charAt","splice"],"mappings":"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","sourcesContent":["/**\n * Expose `pathtoRegexp`.\n */\n\nmodule.exports = pathtoRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n    .replace(/\\/\\(/g, '/(?:')\n    .replace(/([\\/\\.])/g, '\\\\$1')\n    .replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n      slash = slash || '';\n      format = format || '';\n      capture = capture || '([^\\\\/' + format + ']+?)';\n      optional = optional || '';\n\n      keys.push({\n        name: key,\n        optional: !!optional,\n        offset: offset + extraOffset\n      });\n\n      var result = ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + format + (optional ? slash : '') + capture\n        + (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\n        + ')'\n        + optional;\n\n      extraOffset += result.length - match.length;\n\n      return result;\n    })\n    .replace(/\\*/g, function (star, index) {\n      var len = keys.length\n\n      while (len-- > keysOffset && keys[len].offset > index) {\n        keys[len].offset += 3; // Replacement length minus asterisk length.\n      }\n\n      return '(.*)';\n    });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    }\n\n    // It's possible to escape the bracket.\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++, // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  }\n\n  // If the path is non-ending, match until the end or a slash.\n  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\n\n  return new RegExp(path, flags);\n};\n"]},"metadata":{},"sourceType":"script"}