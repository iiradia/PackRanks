{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar DOMNamespaces = require('./DOMNamespaces');\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction'); // SVG temp container for IE lacking innerHTML\n\n\nvar reusableSVGContainer;\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\n\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function (node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      } // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n\n\n      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode\n        // in hopes that this is preserved even if \"\\uFEFF\" is transformed to\n        // the actual Unicode character (by Babel, for example).\n        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216\n        node.innerHTML = String.fromCharCode(0xfeff) + html; // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n\n        var textNode = node.firstChild;\n\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n\n  testElement = null;\n}\n\nmodule.exports = setInnerHTML;","map":{"version":3,"sources":["/Users/mathew/EasyA/reactjs/frontend/node_modules/react-simplert/node_modules/react-dom/lib/setInnerHTML.js"],"names":["ExecutionEnvironment","require","DOMNamespaces","WHITESPACE_TEST","NONVISIBLE_TEST","createMicrosoftUnsafeLocalFunction","reusableSVGContainer","setInnerHTML","node","html","namespaceURI","svg","document","createElement","innerHTML","svgNode","firstChild","appendChild","canUseDOM","testElement","parentNode","replaceChild","test","String","fromCharCode","textNode","data","length","removeChild","deleteData","module","exports"],"mappings":"AAAA;;;;;;;AAQA;;AAEA,IAAIA,oBAAoB,GAAGC,OAAO,CAAC,+BAAD,CAAlC;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;;AAEA,IAAIE,eAAe,GAAG,cAAtB;AACA,IAAIC,eAAe,GAAG,sDAAtB;;AAEA,IAAIC,kCAAkC,GAAGJ,OAAO,CAAC,sCAAD,CAAhD,C,CAEA;;;AACA,IAAIK,oBAAJ;AAEA;;;;;;;;;AAQA,IAAIC,YAAY,GAAGF,kCAAkC,CAAC,UAAUG,IAAV,EAAgBC,IAAhB,EAAsB;AAC1E;AACA;AACA;AACA,MAAID,IAAI,CAACE,YAAL,KAAsBR,aAAa,CAACS,GAApC,IAA2C,EAAE,eAAeH,IAAjB,CAA/C,EAAuE;AACrEF,IAAAA,oBAAoB,GAAGA,oBAAoB,IAAIM,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAA/C;AACAP,IAAAA,oBAAoB,CAACQ,SAArB,GAAiC,UAAUL,IAAV,GAAiB,QAAlD;AACA,QAAIM,OAAO,GAAGT,oBAAoB,CAACU,UAAnC;;AACA,WAAOD,OAAO,CAACC,UAAf,EAA2B;AACzBR,MAAAA,IAAI,CAACS,WAAL,CAAiBF,OAAO,CAACC,UAAzB;AACD;AACF,GAPD,MAOO;AACLR,IAAAA,IAAI,CAACM,SAAL,GAAiBL,IAAjB;AACD;AACF,CAdoD,CAArD;;AAgBA,IAAIT,oBAAoB,CAACkB,SAAzB,EAAoC;AAClC;AACA;AACA;AACA;AAEA;AACA,MAAIC,WAAW,GAAGP,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAlB;AACAM,EAAAA,WAAW,CAACL,SAAZ,GAAwB,GAAxB;;AACA,MAAIK,WAAW,CAACL,SAAZ,KAA0B,EAA9B,EAAkC;AAChCP,IAAAA,YAAY,GAAG,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AACnC;AACA;AACA;AACA;AACA;AACA,UAAID,IAAI,CAACY,UAAT,EAAqB;AACnBZ,QAAAA,IAAI,CAACY,UAAL,CAAgBC,YAAhB,CAA6Bb,IAA7B,EAAmCA,IAAnC;AACD,OARkC,CAUnC;AACA;AACA;AACA;;;AACA,UAAIL,eAAe,CAACmB,IAAhB,CAAqBb,IAArB,KAA8BA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,IAAmBL,eAAe,CAACkB,IAAhB,CAAqBb,IAArB,CAArD,EAAiF;AAC/E;AACA;AACA;AACA;AACA;AACA;AACAD,QAAAA,IAAI,CAACM,SAAL,GAAiBS,MAAM,CAACC,YAAP,CAAoB,MAApB,IAA8Bf,IAA/C,CAP+E,CAS/E;AACA;;AACA,YAAIgB,QAAQ,GAAGjB,IAAI,CAACQ,UAApB;;AACA,YAAIS,QAAQ,CAACC,IAAT,CAAcC,MAAd,KAAyB,CAA7B,EAAgC;AAC9BnB,UAAAA,IAAI,CAACoB,WAAL,CAAiBH,QAAjB;AACD,SAFD,MAEO;AACLA,UAAAA,QAAQ,CAACI,UAAT,CAAoB,CAApB,EAAuB,CAAvB;AACD;AACF,OAjBD,MAiBO;AACLrB,QAAAA,IAAI,CAACM,SAAL,GAAiBL,IAAjB;AACD;AACF,KAlCD;AAmCD;;AACDU,EAAAA,WAAW,GAAG,IAAd;AACD;;AAEDW,MAAM,CAACC,OAAP,GAAiBxB,YAAjB","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar DOMNamespaces = require('./DOMNamespaces');\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function (node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode\n        // in hopes that this is preserved even if \"\\uFEFF\" is transformed to\n        // the actual Unicode character (by Babel, for example).\n        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216\n        node.innerHTML = String.fromCharCode(0xfeff) + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n  testElement = null;\n}\n\nmodule.exports = setInnerHTML;"]},"metadata":{},"sourceType":"script"}