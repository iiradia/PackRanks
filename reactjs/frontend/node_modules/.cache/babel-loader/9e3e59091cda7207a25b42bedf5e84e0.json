{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar CallbackQueue = require('./CallbackQueue');\n\nvar PooledClass = require('./PooledClass');\n\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar Transaction = require('./Transaction');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* useCreateElement */\n  true);\n}\n\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\n\n\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0; // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n\n  dirtyComponents.sort(mountOrderComparator); // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i]; // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n    var markerName;\n\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component; // Duck type TopLevelWrapper. This is probably always true.\n\n      if (component._currentElement.type.isReactTopLevelWrapper) {\n        namedComponent = component._renderedComponent;\n      }\n\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\n\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\n\n\nfunction enqueueUpdate(component) {\n  ensureInjected(); // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\n\n\nfunction asap(callback, context) {\n  invariant(batchingStrategy.isBatchingUpdates, \"ReactUpdates.asap: Can't enqueue an asap callback in a context where\" + 'updates are not being batched.');\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\n    batchingStrategy = _batchingStrategy;\n  }\n};\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\nmodule.exports = ReactUpdates;","map":{"version":3,"sources":["/mnt/c/Users/Harry-PC/Documents/ProgrammingProjects/EasyA/reactjs/frontend/node_modules/react-simplert/node_modules/react-dom/lib/ReactUpdates.js"],"names":["_prodInvariant","require","_assign","CallbackQueue","PooledClass","ReactFeatureFlags","ReactReconciler","Transaction","invariant","dirtyComponents","updateBatchNumber","asapCallbackQueue","getPooled","asapEnqueued","batchingStrategy","ensureInjected","ReactUpdates","ReactReconcileTransaction","process","env","NODE_ENV","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","callbackQueue","reset","notifyAll","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","prototype","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","c","d","e","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","sort","i","component","callbacks","_pendingCallbacks","markerName","logTopLevelRenders","namedComponent","_currentElement","type","isReactTopLevelWrapper","_renderedComponent","getName","console","time","performUpdateIfNecessary","timeEnd","j","enqueue","getPublicInstance","queue","enqueueUpdate","isBatchingUpdates","push","_updateBatchNumber","asap","context","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","injection","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar _prodInvariant = require('./reactProdInvariant'),\n    _assign = require('object-assign');\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactFeatureFlags = require('./ReactFeatureFlags');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* useCreateElement */true);\n}\n\n_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    var markerName;\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component;\n      // Duck type TopLevelWrapper. This is probably always true.\n      if (component._currentElement.type.isReactTopLevelWrapper) {\n        namedComponent = component._renderedComponent;\n      }\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);\n\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  invariant(batchingStrategy.isBatchingUpdates, \"ReactUpdates.asap: Can't enqueue an asap callback in a context where\" + 'updates are not being batched.');\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;"]},"metadata":{},"sourceType":"script"}