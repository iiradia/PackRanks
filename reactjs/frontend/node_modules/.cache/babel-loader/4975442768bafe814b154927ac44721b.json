{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar instantiateReactComponent = require('./instantiateReactComponent');\n\nvar KeyEscapeUtils = require('./KeyEscapeUtils');\n\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\n\nvar traverseAllChildren = require('./traverseAllChildren');\n\nvar warning = require('fbjs/lib/warning');\n\nvar ReactComponentTreeHook;\n\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {\n  // Temporary hack.\n  // Inline requires don't work well with Jest:\n  // https://github.com/facebook/react/issues/7240\n  // Remove the inline requires when we don't need them anymore:\n  // https://github.com/facebook/react/pull/7178\n  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n}\n\nfunction instantiateChild(childInstances, child, name, selfDebugID) {\n  // We found a component instance.\n  var keyUnique = childInstances[name] === undefined;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!ReactComponentTreeHook) {\n      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n    }\n\n    if (!keyUnique) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;\n    }\n  }\n\n  if (child != null && keyUnique) {\n    childInstances[name] = instantiateReactComponent(child, true);\n  }\n}\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\n\n\nvar ReactChildReconciler = {\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots\n  {\n    if (nestedChildNodes == null) {\n      return null;\n    }\n\n    var childInstances = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {\n        return instantiateChild(childInsts, child, name, selfDebugID);\n      }, childInstances);\n    } else {\n      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);\n    }\n\n    return childInstances;\n  },\n\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextChildren Flat child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots\n  {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n\n    var name;\n    var prevChild;\n\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n\n      prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n\n      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n          ReactReconciler.unmountComponent(prevChild, false);\n        } // The child must be instantiated before it's mounted.\n\n\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\n        nextChildren[name] = nextChildInstance; // Creating mount image now ensures refs are resolved in right order\n        // (see https://github.com/facebook/react/pull/7101 for explanation).\n\n        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);\n        mountImages.push(nextChildMountImage);\n      }\n    } // Unmount children that are no longer present.\n\n\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        prevChild = prevChildren[name];\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n        ReactReconciler.unmountComponent(prevChild, false);\n      }\n    }\n  },\n\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function (renderedChildren, safely) {\n    for (var name in renderedChildren) {\n      if (renderedChildren.hasOwnProperty(name)) {\n        var renderedChild = renderedChildren[name];\n        ReactReconciler.unmountComponent(renderedChild, safely);\n      }\n    }\n  }\n};\nmodule.exports = ReactChildReconciler;","map":{"version":3,"sources":["/home/iiradia/EasyA/reactjs/node_modules/react-simplert/node_modules/react-dom/lib/ReactChildReconciler.js"],"names":["ReactReconciler","require","instantiateReactComponent","KeyEscapeUtils","shouldUpdateReactComponent","traverseAllChildren","warning","ReactComponentTreeHook","process","env","NODE_ENV","instantiateChild","childInstances","child","name","selfDebugID","keyUnique","undefined","unescape","getStackAddendumByID","ReactChildReconciler","instantiateChildren","nestedChildNodes","transaction","context","childInsts","updateChildren","prevChildren","nextChildren","mountImages","removedNodes","hostParent","hostContainerInfo","prevChild","hasOwnProperty","prevElement","_currentElement","nextElement","receiveComponent","getHostNode","unmountComponent","nextChildInstance","nextChildMountImage","mountComponent","push","unmountChildren","renderedChildren","safely","renderedChild","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar instantiateReactComponent = require('./instantiateReactComponent');\nvar KeyEscapeUtils = require('./KeyEscapeUtils');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar traverseAllChildren = require('./traverseAllChildren');\nvar warning = require('fbjs/lib/warning');\n\nvar ReactComponentTreeHook;\n\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {\n  // Temporary hack.\n  // Inline requires don't work well with Jest:\n  // https://github.com/facebook/react/issues/7240\n  // Remove the inline requires when we don't need them anymore:\n  // https://github.com/facebook/react/pull/7178\n  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n}\n\nfunction instantiateChild(childInstances, child, name, selfDebugID) {\n  // We found a component instance.\n  var keyUnique = childInstances[name] === undefined;\n  if (process.env.NODE_ENV !== 'production') {\n    if (!ReactComponentTreeHook) {\n      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n    }\n    if (!keyUnique) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;\n    }\n  }\n  if (child != null && keyUnique) {\n    childInstances[name] = instantiateReactComponent(child, true);\n  }\n}\n\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\nvar ReactChildReconciler = {\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots\n  {\n    if (nestedChildNodes == null) {\n      return null;\n    }\n    var childInstances = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {\n        return instantiateChild(childInsts, child, name, selfDebugID);\n      }, childInstances);\n    } else {\n      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);\n    }\n    return childInstances;\n  },\n\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextChildren Flat child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots\n  {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n    var name;\n    var prevChild;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n          ReactReconciler.unmountComponent(prevChild, false);\n        }\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\n        nextChildren[name] = nextChildInstance;\n        // Creating mount image now ensures refs are resolved in right order\n        // (see https://github.com/facebook/react/pull/7101 for explanation).\n        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);\n        mountImages.push(nextChildMountImage);\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        prevChild = prevChildren[name];\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n        ReactReconciler.unmountComponent(prevChild, false);\n      }\n    }\n  },\n\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function (renderedChildren, safely) {\n    for (var name in renderedChildren) {\n      if (renderedChildren.hasOwnProperty(name)) {\n        var renderedChild = renderedChildren[name];\n        ReactReconciler.unmountComponent(renderedChild, safely);\n      }\n    }\n  }\n};\n\nmodule.exports = ReactChildReconciler;"]},"metadata":{},"sourceType":"script"}