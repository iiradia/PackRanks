{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar DOMNamespaces = require('./DOMNamespaces');\n\nvar setInnerHTML = require('./setInnerHTML');\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\n\nvar setTextContent = require('./setTextContent');\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n/**\n * In IE (8-11) and Edge, appending nodes with no children is dramatically\n * faster than appending a full subtree, so we essentially queue up the\n * .appendChild calls here and apply them so each node is added to its parent\n * before any children are added.\n *\n * In other browsers, doing so is slower or neutral compared to the other order\n * (in Firefox, twice as slow) so we only do this inversion in IE.\n *\n * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.\n */\n\nvar enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\\bEdge\\/\\d/.test(navigator.userAgent);\n\nfunction insertTreeChildren(tree) {\n  if (!enableLazy) {\n    return;\n  }\n\n  var node = tree.node;\n  var children = tree.children;\n\n  if (children.length) {\n    for (var i = 0; i < children.length; i++) {\n      insertTreeBefore(node, children[i], null);\n    }\n  } else if (tree.html != null) {\n    setInnerHTML(node, tree.html);\n  } else if (tree.text != null) {\n    setTextContent(node, tree.text);\n  }\n}\n\nvar insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {\n  // DocumentFragments aren't actually part of the DOM after insertion so\n  // appending children won't update the DOM. We need to ensure the fragment\n  // is properly populated first, breaking out of our lazy approach for just\n  // this level. Also, some <object> plugins (like Flash Player) will read\n  // <param> nodes immediately upon insertion into the DOM, so <object>\n  // must also be populated prior to insertion into the DOM.\n  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {\n    insertTreeChildren(tree);\n    parentNode.insertBefore(tree.node, referenceNode);\n  } else {\n    parentNode.insertBefore(tree.node, referenceNode);\n    insertTreeChildren(tree);\n  }\n});\n\nfunction replaceChildWithTree(oldNode, newTree) {\n  oldNode.parentNode.replaceChild(newTree.node, oldNode);\n  insertTreeChildren(newTree);\n}\n\nfunction queueChild(parentTree, childTree) {\n  if (enableLazy) {\n    parentTree.children.push(childTree);\n  } else {\n    parentTree.node.appendChild(childTree.node);\n  }\n}\n\nfunction queueHTML(tree, html) {\n  if (enableLazy) {\n    tree.html = html;\n  } else {\n    setInnerHTML(tree.node, html);\n  }\n}\n\nfunction queueText(tree, text) {\n  if (enableLazy) {\n    tree.text = text;\n  } else {\n    setTextContent(tree.node, text);\n  }\n}\n\nfunction toString() {\n  return this.node.nodeName;\n}\n\nfunction DOMLazyTree(node) {\n  return {\n    node: node,\n    children: [],\n    html: null,\n    text: null,\n    toString: toString\n  };\n}\n\nDOMLazyTree.insertTreeBefore = insertTreeBefore;\nDOMLazyTree.replaceChildWithTree = replaceChildWithTree;\nDOMLazyTree.queueChild = queueChild;\nDOMLazyTree.queueHTML = queueHTML;\nDOMLazyTree.queueText = queueText;\nmodule.exports = DOMLazyTree;","map":{"version":3,"sources":["/Users/mathew/EasyA/reactjs/frontend/node_modules/react-simplert/node_modules/react-dom/lib/DOMLazyTree.js"],"names":["DOMNamespaces","require","setInnerHTML","createMicrosoftUnsafeLocalFunction","setTextContent","ELEMENT_NODE_TYPE","DOCUMENT_FRAGMENT_NODE_TYPE","enableLazy","document","documentMode","navigator","userAgent","test","insertTreeChildren","tree","node","children","length","i","insertTreeBefore","html","text","parentNode","referenceNode","nodeType","nodeName","toLowerCase","namespaceURI","insertBefore","replaceChildWithTree","oldNode","newTree","replaceChild","queueChild","parentTree","childTree","push","appendChild","queueHTML","queueText","toString","DOMLazyTree","module","exports"],"mappings":"AAAA;;;;;;;AAQA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,gBAAD,CAA1B;;AAEA,IAAIE,kCAAkC,GAAGF,OAAO,CAAC,sCAAD,CAAhD;;AACA,IAAIG,cAAc,GAAGH,OAAO,CAAC,kBAAD,CAA5B;;AAEA,IAAII,iBAAiB,GAAG,CAAxB;AACA,IAAIC,2BAA2B,GAAG,EAAlC;AAEA;;;;;;;;;;;;AAWA,IAAIC,UAAU,GAAG,OAAOC,QAAP,KAAoB,WAApB,IAAmC,OAAOA,QAAQ,CAACC,YAAhB,KAAiC,QAApE,IAAgF,OAAOC,SAAP,KAAqB,WAArB,IAAoC,OAAOA,SAAS,CAACC,SAAjB,KAA+B,QAAnE,IAA+E,aAAaC,IAAb,CAAkBF,SAAS,CAACC,SAA5B,CAAhL;;AAEA,SAASE,kBAAT,CAA4BC,IAA5B,EAAkC;AAChC,MAAI,CAACP,UAAL,EAAiB;AACf;AACD;;AACD,MAAIQ,IAAI,GAAGD,IAAI,CAACC,IAAhB;AACA,MAAIC,QAAQ,GAAGF,IAAI,CAACE,QAApB;;AACA,MAAIA,QAAQ,CAACC,MAAb,EAAqB;AACnB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACC,MAA7B,EAAqCC,CAAC,EAAtC,EAA0C;AACxCC,MAAAA,gBAAgB,CAACJ,IAAD,EAAOC,QAAQ,CAACE,CAAD,CAAf,EAAoB,IAApB,CAAhB;AACD;AACF,GAJD,MAIO,IAAIJ,IAAI,CAACM,IAAL,IAAa,IAAjB,EAAuB;AAC5BlB,IAAAA,YAAY,CAACa,IAAD,EAAOD,IAAI,CAACM,IAAZ,CAAZ;AACD,GAFM,MAEA,IAAIN,IAAI,CAACO,IAAL,IAAa,IAAjB,EAAuB;AAC5BjB,IAAAA,cAAc,CAACW,IAAD,EAAOD,IAAI,CAACO,IAAZ,CAAd;AACD;AACF;;AAED,IAAIF,gBAAgB,GAAGhB,kCAAkC,CAAC,UAAUmB,UAAV,EAAsBR,IAAtB,EAA4BS,aAA5B,EAA2C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,MAAIT,IAAI,CAACC,IAAL,CAAUS,QAAV,KAAuBlB,2BAAvB,IAAsDQ,IAAI,CAACC,IAAL,CAAUS,QAAV,KAAuBnB,iBAAvB,IAA4CS,IAAI,CAACC,IAAL,CAAUU,QAAV,CAAmBC,WAAnB,OAAqC,QAAjF,KAA8FZ,IAAI,CAACC,IAAL,CAAUY,YAAV,IAA0B,IAA1B,IAAkCb,IAAI,CAACC,IAAL,CAAUY,YAAV,KAA2B3B,aAAa,CAACoB,IAAzK,CAA1D,EAA0O;AACxOP,IAAAA,kBAAkB,CAACC,IAAD,CAAlB;AACAQ,IAAAA,UAAU,CAACM,YAAX,CAAwBd,IAAI,CAACC,IAA7B,EAAmCQ,aAAnC;AACD,GAHD,MAGO;AACLD,IAAAA,UAAU,CAACM,YAAX,CAAwBd,IAAI,CAACC,IAA7B,EAAmCQ,aAAnC;AACAV,IAAAA,kBAAkB,CAACC,IAAD,CAAlB;AACD;AACF,CAdwD,CAAzD;;AAgBA,SAASe,oBAAT,CAA8BC,OAA9B,EAAuCC,OAAvC,EAAgD;AAC9CD,EAAAA,OAAO,CAACR,UAAR,CAAmBU,YAAnB,CAAgCD,OAAO,CAAChB,IAAxC,EAA8Ce,OAA9C;AACAjB,EAAAA,kBAAkB,CAACkB,OAAD,CAAlB;AACD;;AAED,SAASE,UAAT,CAAoBC,UAApB,EAAgCC,SAAhC,EAA2C;AACzC,MAAI5B,UAAJ,EAAgB;AACd2B,IAAAA,UAAU,CAAClB,QAAX,CAAoBoB,IAApB,CAAyBD,SAAzB;AACD,GAFD,MAEO;AACLD,IAAAA,UAAU,CAACnB,IAAX,CAAgBsB,WAAhB,CAA4BF,SAAS,CAACpB,IAAtC;AACD;AACF;;AAED,SAASuB,SAAT,CAAmBxB,IAAnB,EAAyBM,IAAzB,EAA+B;AAC7B,MAAIb,UAAJ,EAAgB;AACdO,IAAAA,IAAI,CAACM,IAAL,GAAYA,IAAZ;AACD,GAFD,MAEO;AACLlB,IAAAA,YAAY,CAACY,IAAI,CAACC,IAAN,EAAYK,IAAZ,CAAZ;AACD;AACF;;AAED,SAASmB,SAAT,CAAmBzB,IAAnB,EAAyBO,IAAzB,EAA+B;AAC7B,MAAId,UAAJ,EAAgB;AACdO,IAAAA,IAAI,CAACO,IAAL,GAAYA,IAAZ;AACD,GAFD,MAEO;AACLjB,IAAAA,cAAc,CAACU,IAAI,CAACC,IAAN,EAAYM,IAAZ,CAAd;AACD;AACF;;AAED,SAASmB,QAAT,GAAoB;AAClB,SAAO,KAAKzB,IAAL,CAAUU,QAAjB;AACD;;AAED,SAASgB,WAAT,CAAqB1B,IAArB,EAA2B;AACzB,SAAO;AACLA,IAAAA,IAAI,EAAEA,IADD;AAELC,IAAAA,QAAQ,EAAE,EAFL;AAGLI,IAAAA,IAAI,EAAE,IAHD;AAILC,IAAAA,IAAI,EAAE,IAJD;AAKLmB,IAAAA,QAAQ,EAAEA;AALL,GAAP;AAOD;;AAEDC,WAAW,CAACtB,gBAAZ,GAA+BA,gBAA/B;AACAsB,WAAW,CAACZ,oBAAZ,GAAmCA,oBAAnC;AACAY,WAAW,CAACR,UAAZ,GAAyBA,UAAzB;AACAQ,WAAW,CAACH,SAAZ,GAAwBA,SAAxB;AACAG,WAAW,CAACF,SAAZ,GAAwBA,SAAxB;AAEAG,MAAM,CAACC,OAAP,GAAiBF,WAAjB","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar DOMNamespaces = require('./DOMNamespaces');\nvar setInnerHTML = require('./setInnerHTML');\n\nvar createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');\nvar setTextContent = require('./setTextContent');\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\n/**\n * In IE (8-11) and Edge, appending nodes with no children is dramatically\n * faster than appending a full subtree, so we essentially queue up the\n * .appendChild calls here and apply them so each node is added to its parent\n * before any children are added.\n *\n * In other browsers, doing so is slower or neutral compared to the other order\n * (in Firefox, twice as slow) so we only do this inversion in IE.\n *\n * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.\n */\nvar enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\\bEdge\\/\\d/.test(navigator.userAgent);\n\nfunction insertTreeChildren(tree) {\n  if (!enableLazy) {\n    return;\n  }\n  var node = tree.node;\n  var children = tree.children;\n  if (children.length) {\n    for (var i = 0; i < children.length; i++) {\n      insertTreeBefore(node, children[i], null);\n    }\n  } else if (tree.html != null) {\n    setInnerHTML(node, tree.html);\n  } else if (tree.text != null) {\n    setTextContent(node, tree.text);\n  }\n}\n\nvar insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {\n  // DocumentFragments aren't actually part of the DOM after insertion so\n  // appending children won't update the DOM. We need to ensure the fragment\n  // is properly populated first, breaking out of our lazy approach for just\n  // this level. Also, some <object> plugins (like Flash Player) will read\n  // <param> nodes immediately upon insertion into the DOM, so <object>\n  // must also be populated prior to insertion into the DOM.\n  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {\n    insertTreeChildren(tree);\n    parentNode.insertBefore(tree.node, referenceNode);\n  } else {\n    parentNode.insertBefore(tree.node, referenceNode);\n    insertTreeChildren(tree);\n  }\n});\n\nfunction replaceChildWithTree(oldNode, newTree) {\n  oldNode.parentNode.replaceChild(newTree.node, oldNode);\n  insertTreeChildren(newTree);\n}\n\nfunction queueChild(parentTree, childTree) {\n  if (enableLazy) {\n    parentTree.children.push(childTree);\n  } else {\n    parentTree.node.appendChild(childTree.node);\n  }\n}\n\nfunction queueHTML(tree, html) {\n  if (enableLazy) {\n    tree.html = html;\n  } else {\n    setInnerHTML(tree.node, html);\n  }\n}\n\nfunction queueText(tree, text) {\n  if (enableLazy) {\n    tree.text = text;\n  } else {\n    setTextContent(tree.node, text);\n  }\n}\n\nfunction toString() {\n  return this.node.nodeName;\n}\n\nfunction DOMLazyTree(node) {\n  return {\n    node: node,\n    children: [],\n    html: null,\n    text: null,\n    toString: toString\n  };\n}\n\nDOMLazyTree.insertTreeBefore = insertTreeBefore;\nDOMLazyTree.replaceChildWithTree = replaceChildWithTree;\nDOMLazyTree.queueChild = queueChild;\nDOMLazyTree.queueHTML = queueHTML;\nDOMLazyTree.queueText = queueText;\n\nmodule.exports = DOMLazyTree;"]},"metadata":{},"sourceType":"script"}