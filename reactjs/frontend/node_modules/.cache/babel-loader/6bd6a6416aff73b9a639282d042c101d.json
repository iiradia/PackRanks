{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\n\nvar EventPropagators = require('./EventPropagators');\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\n\nvar ReactUpdates = require('./ReactUpdates');\n\nvar SyntheticEvent = require('./SyntheticEvent');\n\nvar inputValueTracking = require('./inputValueTracking');\n\nvar getEventTarget = require('./getEventTarget');\n\nvar isEventSupported = require('./isEventSupported');\n\nvar isTextInputElement = require('./isTextInputElement');\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);\n  event.type = 'change';\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\n\n\nvar activeElement = null;\nvar activeElementInst = null;\n/**\n * SECTION: handle `change` event\n */\n\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nvar doesChangeEventBubble = false;\n\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\n\nfunction startWatchingForChangeEventIE8(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementInst = null;\n}\n\nfunction getInstIfValueChanged(targetInst, nativeEvent) {\n  var updated = inputValueTracking.updateValueIfChanged(targetInst);\n  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;\n\n  if (updated || simulated) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\nfunction handleEventsForChangeEventIE8(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForChangeEventIE8();\n  }\n}\n/**\n * SECTION: handle `input` event\n */\n\n\nvar isInputEventSupported = false;\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\n\n\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\n\n\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\n\n\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n\n  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n} // For IE8 and IE9.\n\n\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst, nativeEvent);\n  }\n}\n/**\n * SECTION: handle `click` event\n */\n\n\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  } // Fiber and ReactDOM keep wrapper state in separate places\n\n\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  } // If controlled, assign the value attribute to the current value on blur\n\n\n  var value = '' + node.value;\n\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\n\n\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes,\n  _allowSimulatedPassThrough: true,\n  _isInputEventSupported: isInputEventSupported,\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;\n    var getTargetInstFunc, handleEventFunc;\n\n    if (shouldUseChangeEvent(targetNode)) {\n      if (doesChangeEventBubble) {\n        getTargetInstFunc = getTargetInstForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);\n\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    } // When blurring, set the value attribute for number inputs\n\n\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\nmodule.exports = ChangeEventPlugin;","map":{"version":3,"sources":["/home/iiradia/EasyA/reactjs/frontend/node_modules/react-simplert/node_modules/react-dom/lib/ChangeEventPlugin.js"],"names":["EventPluginHub","require","EventPropagators","ExecutionEnvironment","ReactDOMComponentTree","ReactUpdates","SyntheticEvent","inputValueTracking","getEventTarget","isEventSupported","isTextInputElement","eventTypes","change","phasedRegistrationNames","bubbled","captured","dependencies","createAndAccumulateChangeEvent","inst","nativeEvent","target","event","getPooled","type","accumulateTwoPhaseDispatches","activeElement","activeElementInst","shouldUseChangeEvent","elem","nodeName","toLowerCase","doesChangeEventBubble","canUseDOM","document","documentMode","manualDispatchChangeEvent","batchedUpdates","runEventInBatch","enqueueEvents","processEventQueue","startWatchingForChangeEventIE8","targetInst","attachEvent","stopWatchingForChangeEventIE8","detachEvent","getInstIfValueChanged","updated","updateValueIfChanged","simulated","ChangeEventPlugin","_allowSimulatedPassThrough","getTargetInstForChangeEvent","topLevelType","handleEventsForChangeEventIE8","isInputEventSupported","startWatchingForValueChange","handlePropertyChange","stopWatchingForValueChange","propertyName","handleEventsForInputEventPolyfill","getTargetInstForInputEventPolyfill","shouldUseClickEvent","getTargetInstForClickEvent","getTargetInstForInputOrChangeEvent","handleControlledInputBlur","node","state","_wrapperState","controlled","value","getAttribute","setAttribute","_isInputEventSupported","extractEvents","nativeEventTarget","targetNode","getNodeFromInstance","window","getTargetInstFunc","handleEventFunc","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPropagators = require('./EventPropagators');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactUpdates = require('./ReactUpdates');\nvar SyntheticEvent = require('./SyntheticEvent');\n\nvar inputValueTracking = require('./inputValueTracking');\nvar getEventTarget = require('./getEventTarget');\nvar isEventSupported = require('./isEventSupported');\nvar isTextInputElement = require('./isTextInputElement');\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);\n  event.type = 'change';\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\n\nfunction startWatchingForChangeEventIE8(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementInst = null;\n}\n\nfunction getInstIfValueChanged(targetInst, nativeEvent) {\n  var updated = inputValueTracking.updateValueIfChanged(targetInst);\n  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;\n\n  if (updated || simulated) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\nfunction handleEventsForChangeEventIE8(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst, nativeEvent);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst, nativeEvent);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes,\n\n  _allowSimulatedPassThrough: true,\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      if (doesChangeEventBubble) {\n        getTargetInstFunc = getTargetInstForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\nmodule.exports = ChangeEventPlugin;"]},"metadata":{},"sourceType":"script"}