{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar EventListener = require('fbjs/lib/EventListener');\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar PooledClass = require('./PooledClass');\n\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\n\nvar ReactUpdates = require('./ReactUpdates');\n\nvar getEventTarget = require('./getEventTarget');\n\nvar getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\n\n\nfunction findParent(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst._hostParent) {\n    inst = inst._hostParent;\n  }\n\n  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);\n  var container = rootNode.parentNode;\n  return ReactDOMComponentTree.getClosestInstanceFromNode(container);\n} // Used to store ancestor hierarchy in top level callback\n\n\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\n\n_assign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function () {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\n\nPooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);\n  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget); // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n\n  var ancestor = targetInst;\n\n  do {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = ancestor && findParent(ancestor);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n  setHandleTopLevel: function (handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n  setEnabled: function (enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n  isEnabled: function () {\n    return ReactEventListener._enabled;\n  },\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} element Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {\n    if (!element) {\n      return null;\n    }\n\n    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} element Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {\n    if (!element) {\n      return null;\n    }\n\n    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n  monitorScrollValue: function (refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n  dispatchEvent: function (topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);\n\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\nmodule.exports = ReactEventListener;","map":{"version":3,"sources":["/home/iiradia/EasyA/reactjs/frontend/node_modules/react-simplert/node_modules/react-dom/lib/ReactEventListener.js"],"names":["_assign","require","EventListener","ExecutionEnvironment","PooledClass","ReactDOMComponentTree","ReactUpdates","getEventTarget","getUnboundedScrollPosition","findParent","inst","_hostParent","rootNode","getNodeFromInstance","container","parentNode","getClosestInstanceFromNode","TopLevelCallbackBookKeeping","topLevelType","nativeEvent","ancestors","prototype","destructor","length","addPoolingTo","twoArgumentPooler","handleTopLevelImpl","bookKeeping","nativeEventTarget","targetInst","ancestor","push","i","ReactEventListener","_handleTopLevel","scrollValueMonitor","cb","scrollPosition","window","_enabled","WINDOW_HANDLE","canUseDOM","setHandleTopLevel","handleTopLevel","setEnabled","enabled","isEnabled","trapBubbledEvent","handlerBaseName","element","listen","dispatchEvent","bind","trapCapturedEvent","capture","monitorScrollValue","refresh","callback","getPooled","batchedUpdates","release","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar EventListener = require('fbjs/lib/EventListener');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar PooledClass = require('./PooledClass');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar getEventTarget = require('./getEventTarget');\nvar getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findParent(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst._hostParent) {\n    inst = inst._hostParent;\n  }\n  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);\n  var container = rootNode.parentNode;\n  return ReactDOMComponentTree.getClosestInstanceFromNode(container);\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\n_assign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function () {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);\n  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = ancestor && findParent(ancestor);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n\n  setHandleTopLevel: function (handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function (enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function () {\n    return ReactEventListener._enabled;\n  },\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} element Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} element Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  monitorScrollValue: function (refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n\n  dispatchEvent: function (topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\n\nmodule.exports = ReactEventListener;"]},"metadata":{},"sourceType":"script"}